{"meta":{"title":"korealu","subtitle":"总是不安于现状","description":"只有不断的努力，才能实现自己的梦想","author":"korealu","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"jsonp解决跨域原理.md","slug":"jsonp解决跨域原理-md","date":"2019-11-04T15:28:10.000Z","updated":"2019-11-04T15:28:23.294Z","comments":true,"path":"2019/11/04/jsonp解决跨域原理-md/","link":"","permalink":"http://yoursite.com/2019/11/04/jsonp%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E5%8E%9F%E7%90%86-md/","excerpt":"","text":"1. jsonp解决ajax跨域的原理1). jsonp只能解决GET类型的ajax请求跨域问题 2). jsonp请求不是ajax请求, 而是一般的get请求 3). 基本原理 浏览器端: 动态生成&lt;script&gt;来请求后台接口(src就是接口的url) 定义好用于接收响应数据的函数(fn), 并将函数名通过请求参数提交给后台(如: callback=fn) 服务器端: 接收到请求处理产生结果数据后, 返回一个函数调用的js代码, 并将结果数据作为实参传入函数调用 浏览器端: 收到响应自动执行函数调用的js代码, 也就执行了提前定义好的回调函数, 并得到了需要的结果数据","categories":[],"tags":[]},{"title":"公用函数.md","slug":"公用函数-md","date":"2019-11-04T15:25:11.000Z","updated":"2019-11-04T15:25:39.413Z","comments":true,"path":"2019/11/04/公用函数-md/","link":"","permalink":"http://yoursite.com/2019/11/04/%E5%85%AC%E7%94%A8%E5%87%BD%E6%95%B0-md/","excerpt":"","text":"常用函数1. static: 检测数据是不是除了symbol外的原始数据123function isStatic(value) &#123; return (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean' || typeof value === 'undefined' || value === null)&#125; 2. isPrimitive：检测数据是不是原始数据123function isPrimitive(value) &#123; return isStatic(value) || typeof value === 'symbol'&#125; 3. isObject：判断数据是不是引用类型的数据 (例如: arrays, functions, objects, regexes, new Number(0),以及 new String(‘’))1234function isObject(value) &#123; let type = typeof value; return value != null &amp;&amp; (type == 'object' || type == 'function');&#125; 4. isObjectLike: 检查 value 是否是 类对象,如果一个值是类对象，那么它不应该是 null，而且 typeof 后的结果是 “object”123function isObjectLike(value) &#123; return value != null &amp;&amp; typeof value == 'object';&#125; 5. getRawType：获取数据类型，返回结果为 Number、String、Object、Array等123function getRawType(value) &#123; return Object.prototype.toString.call(value).slice(8, -1)&#125;//getoRawType([]) ==&gt; Array 6. isPlainObject：判断数据是不是Object类型的数据123function isPlainObject(obj) &#123; return Object.prototype.toString.call(obj) === '[object Object]'&#125; 7. isArray：判断数据是不是数组类型的数据123function isArray(arr) &#123; return Object.prototype.toString.call(arr) === '[object Array]'&#125; ​ 将isArray挂载到Array上 1Array.isArray = Array.isArray || isArray; 8. isRegExp：判断数据是不是正则对象123function isRegExp(value) &#123; return Object.prototype.toString.call(value) === '[object RegExp]'&#125; 9. isDate：判断数据是不是时间对象123function isDate(value) &#123; return Object.prototype.toString.call(value) === '[object Date]'&#125; 10. isNative：判断 value 是不是浏览器内置函数内置函数toString后的主体代码块为 [native code] ，而非内置函数则为相关代码，所以非内置函数可以进行拷贝(toString后掐头去尾再由Function转) 123function isNative(value) &#123; return typeof value === 'function' &amp;&amp; /native code/.test(value.toString())&#125; 11. isFunction：检查 value 是不是函数123function isFunction(value) &#123; return Object.prototype.toString.call(value) === '[object Function]'&#125; 12.isLength：检查 value 是否为有效的类数组长度123function isLength(value) &#123; return typeof value == 'number' &amp;&amp; value &gt; -1 &amp;&amp; value % 1 == 0 &amp;&amp; value &lt;= Number.MAX_SAFE_INTEGER;&#125; 13. isArrayLike：检查 value 是否是类数组如果一个值被认为是类数组，那么它不是一个函数，并且value.length是个整数，大于等于 0，小于或等于 Number.MAX_SAFE_INTEGER。这里字符串也将被当作类数组。 123function isArrayLike(value) &#123; return value != null &amp;&amp; isLength(value.length) &amp;&amp; !isFunction(value);&#125; 14.isEmpty：检查 value 是否为空如果是null，直接返回true；如果是类数组，判断数据长度；如果是Object对象，判断是否具有属性；如果是其他数据，直接返回false(也可改为返回true) 123456789101112function isEmpty(value) &#123; if (value == null) &#123; return true; &#125; if (isArrayLike(value)) &#123; return !value.length; &#125; else if(isPlainObject(value))&#123; for (let key in value) &#123; if (hasOwnProperty.call(value, key)) &#123; return false; &#125; &#125; &#125; return false;&#125; 15. cached: 记忆函数: 缓存函数的运算结果1234567function cached(fn) &#123; let cache = Object.create(null); return function cachedFn(str) &#123; let hit = cache[str]; return hit || (cache[str] = fn(str)) &#125;&#125; 16. camelize: 横线转驼峰命名1234let camelizeRE = /-(\\w)/g;function camelize(str) &#123; return str.replace(camelizeRE, function(_, c) &#123; return c ? c.toUpperCase() : ''; &#125;) &#125;//ab-cd-ef ==&gt; abCdEf//使用记忆函数let _camelize = cached(camelize) 17. hyphenate：驼峰命名转横线命名: 拆分字符串，使用 - 相连，并且转换为小写12let hyphenateRE = /\\B([A-Z])/g;function hyphenate(str) &#123; return str.replace(hyphenateRE, '-$1').toLowerCase()&#125;//abCd ==&gt; ab-cd//使用记忆函数let _hyphenate = cached(hyphenate); 18.capitalize：字符串首位大写1234function capitalize(str)&#123; return str.charAt(0).toUpperCase() + str.slice(1)&#125;// abc ==&gt; Abc//使用记忆函数let _capitalize = cached(capitalize) 19. extend：将属性混合到目标对象中123456function extend(to, _from) &#123; for(let key in _from) &#123; to[key] = _from[key]; &#125; return to&#125; 20. Object.assign: 对象属性复制，浅拷贝123456789Object.assign = Object.assign || function()&#123; if(arguments.length == 0) throw new TypeError('Cannot convert undefined or null to object'); let target = arguments[0], args = Array.prototype.slice.call(arguments, 1), key args.forEach(function(item)&#123; for(key in item)&#123; item.hasOwnProperty(key) &amp;&amp; ( target[key] = item[key] ) &#125; &#125;) return target&#125; 使用Object.assign可以浅克隆一个对象： 1let clone = Object.assign(&#123;&#125;, target) 简单的深克隆可以使用JSON.parse()和JSON.stringify()，这两个api是解析json数据的，所以只能解析除symbol外的原始类型及数组和对象 1let clone = JSON.parse( JSON.stringify(target) ) 21. clone: 克隆数据，可深度克隆这里列出了原始类型，时间、正则、错误、数组、对象的克隆规则，其他的可自行补充 123456789101112131415161718192021function clone(value, deep)&#123; if(isPrimitive(value))&#123; return value &#125; if (isArrayLike(value)) &#123; //是类数组 value = Array.prototype.slice.call(value) return value.map(item =&gt; deep ? clone(item, deep) : item) &#125;else if(isPlainObject(value))&#123; //是对象 let target = &#123;&#125;, key; for (key in value) &#123; value.hasOwnProperty(key) &amp;&amp; ( target[key] = deep ? clone(value[key], deep) : value[key] ) &#125; &#125; let type = getRawType(value) switch(type)&#123; case 'Date': case 'RegExp': case 'Error': value = new window[type](value); break; &#125; return value&#125; 22. 识别各种浏览器及平台123456789101112//运行环境是浏览器let inBrowser = typeof window !== 'undefined'; //运行环境是微信let inWeex = typeof WXEnvironment !== 'undefined' &amp;&amp; !!WXEnvironment.platform;let weexPlatform = inWeex &amp;&amp; WXEnvironment.platform.toLowerCase();//浏览器 UA 判断let UA = inBrowser &amp;&amp; window.navigator.userAgent.toLowerCase();let isIE = UA &amp;&amp; /msie|trident/.test(UA);let isIE9 = UA &amp;&amp; UA.indexOf('msie 9.0') &gt; 0;let isEdge = UA &amp;&amp; UA.indexOf('edge/') &gt; 0;let isAndroid = (UA &amp;&amp; UA.indexOf('android') &gt; 0) || (weexPlatform === 'android');let isIOS = (UA &amp;&amp; /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');let isChrome = UA &amp;&amp; /chrome\\/\\d+/.test(UA) &amp;&amp; !isEdge; 23. getExplorerInfo: 获取浏览器信息1234567891011121314151617181920212223242526272829function getExplorerInfo() &#123; let t = navigator.userAgent.toLowerCase(); return 0 &lt;= t.indexOf(\"msie\") ? &#123; //ie &lt; 11 type: \"IE\", version: Number(t.match(/msie ([\\d]+)/)[1]) &#125; : !!t.match(/trident\\/.+?rv:(([\\d.]+))/) ? &#123; // ie 11 type: \"IE\", version: 11 &#125; : 0 &lt;= t.indexOf(\"edge\") ? &#123; type: \"Edge\", version: Number(t.match(/edge\\/([\\d]+)/)[1]) &#125; : 0 &lt;= t.indexOf(\"firefox\") ? &#123; type: \"Firefox\", version: Number(t.match(/firefox\\/([\\d]+)/)[1]) &#125; : 0 &lt;= t.indexOf(\"chrome\") ? &#123; type: \"Chrome\", version: Number(t.match(/chrome\\/([\\d]+)/)[1]) &#125; : 0 &lt;= t.indexOf(\"opera\") ? &#123; type: \"Opera\", version: Number(t.match(/opera.([\\d]+)/)[1]) &#125; : 0 &lt;= t.indexOf(\"Safari\") ? &#123; type: \"Safari\", version: Number(t.match(/version\\/([\\d]+)/)[1]) &#125; : &#123; type: t, version: -1 &#125;&#125; 24. isPCBroswer: 检测是否为PC端浏览器模式123456789101112function isPCBroswer() &#123; let e = navigator.userAgent.toLowerCase(), t = \"ipad\" == e.match(/ipad/i), i = \"iphone\" == e.match(/iphone/i), r = \"midp\" == e.match(/midp/i), n = \"rv:1.2.3.4\" == e.match(/rv:1.2.3.4/i), a = \"ucweb\" == e.match(/ucweb/i), o = \"android\" == e.match(/android/i), s = \"windows ce\" == e.match(/windows ce/i), l = \"windows mobile\" == e.match(/windows mobile/i); return !(t || i || r || n || a || o || s || l)&#125; 25. unique: 数组去重，返回一个新数组123456789101112131415161718192021function unique(arr) &#123; if (!isArrayLink(arr)) &#123; //不是类数组对象 return arr &#125; let result = [] let objarr = [] let obj = Object.create(null) arr.forEach(item =&gt; &#123; if (isStatic(item)) &#123; //是除了symbol外的原始数据 let key = item + '_' + getRawType(item); if (!obj[key]) &#123; obj[key] = true result.push(item) &#125; &#125; else &#123; // 引用类型及symbol if (!objarr.includes(item)) &#123; objarr.push(item) result.push(item) &#125; &#125; &#125;) return resulte&#125; 26. Set简单实现1234567891011121314151617181920212223242526272829303132333435window.Set = window.Set || (function () &#123; function Set(arr) &#123; this.items = arr ? unique(arr) : []; this.size = this.items.length; // Array的大小 &#125; Set.prototype = &#123; add: function (value) &#123; // 添加元素,若元素已存在,则跳过，返回 Set 结构本身。 if (!this.has(value)) &#123; this.items.push(value); this.size++; &#125; return this; &#125;, clear: function () &#123; //清除所有成员，没有返回值。 this.items = [] this.size = 0 &#125;, delete: function (value) &#123; //删除某个值，返回一个布尔值，表示删除是否成功。 return this.items.some((v, i) =&gt; &#123; if (v === value) &#123; this.items.splice(i, 1) return true &#125; return false &#125;) &#125;, has: function (value) &#123; //返回一个布尔值，表示该值是否为Set的成员。 return this.items.some(v =&gt; v === value) &#125;, values: function () &#123; return this.items &#125;, &#125; return Set;&#125;()); 27. repeat: 生成一个重复的字符串，有n个str组成，可修改为填充为数组等12345678910111213function repeat(str, n) &#123; let res = ''; while (n) &#123; if (n % 2 === 1) &#123; res += str; &#125; if (n &gt; 1) &#123; str += str; &#125; n &gt;&gt;= 1; &#125; return res&#125;; //repeat('123',3) ==&gt; 123123123 28. dateFormater: 格式化时间123456789101112function dateFormater(formater, t) &#123; let date = t ? new Date(t) : new Date(), Y = date.getFullYear() + '', M = date.getMonth() + 1, D = date.getDate(), H = date.getHours(), m = date.getMinutes(), s = date.getSeconds(); return formater.replace(/YYYY|yyyy/g, Y).replace(/YY|yy/g, Y.substr(2, 2)).replace(/MM/g, (M &lt; 10 ? '0' : '') + M).replace( /DD/g, (D &lt; 10 ? '0' : '') + D).replace(/HH|hh/g, (H &lt; 10 ? '0' : '') + H).replace(/mm/g, (m &lt; 10 ? '0' : '') + m).replace(/ss/g, (s &lt; 10 ? '0' : '') + s)&#125; // dateFormater('YYYY-MM-DD HH:mm', t) ==&gt; 2019-06-26 18:30// dateFormater('YYYYMMDDHHmm', t) ==&gt; 201906261830 29. dateStrForma: 将指定字符串由一种时间格式转化为另一种from的格式应对应str的位置 12345678910111213function dateStrForma(str, from, to) &#123; str += '' let Y = '' if (~(Y = from.indexOf('YYYY'))) &#123; Y = str.substr(Y, 4) to = to.replace(/YYYY|yyyy/g, Y) &#125; else if (~(Y = from.indexOf('YY'))) &#123; Y = str.substr(Y, 2) to = to.replace(/YY|yy/g, Y) &#125; let k, i['M', 'D', 'H', 'h', 'm', 's'].forEach(s =&gt; &#123; i = from.indexOf(s + s) k = ~i ? str.substr(i, 2) : '' to = to.replace(s + s, k) &#125;) return to&#125; 30. getPropByPath: 根据字符串路径获取对象属性 : ‘obj[0].count’1234567891011121314151617181920212223242526272829function getPropByPath(obj, path, strict) &#123; let tempObj = obj; path = path.replace(/\\[(\\w+)\\]/g, '.$1'); //将[0]转化为.0 path = path.replace(/^\\./, ''); //去除开头的. let keyArr = path.split('.'); //根据.切割 let i = 0; for (let len = keyArr.length; i &lt; len - 1; ++i) &#123; if (!tempObj &amp;&amp; !strict) break; let key = keyArr[i]; if (key in tempObj) &#123; tempObj = tempObj[key]; &#125; else &#123; if (strict) &#123; //开启严格模式，没找到对应key值，抛出错误 throw new Error('please transfer a valid prop path to form item!'); &#125; break; &#125; &#125; return &#123; o: tempObj, //原始数据 k: keyArr[i], //key值 v: tempObj ? tempObj[keyArr[i]] : null // key值对应的值 &#125;;&#125;; 31. GetUrlParam: 获取Url参数，返回一个对象123456789101112function GetUrlParam() &#123; let url = document.location.toString(); let arrObj = url.split(\"?\"); let params = Object.create(null) if (arrObj.length &gt; 1) &#123; arrObj = arrObj[1].split(\"&amp;\"); arrObj.forEach(item =&gt; &#123; item = item.split(\"=\"); params[item[0]] = item[1] &#125;) &#125; return params;&#125; // ?a=1&amp;b=2&amp;c=3 ==&gt; &#123;a: \"1\", b: \"2\", c: \"3\"&#125; 32. downloadFile: base64数据导出文件，文件下载12345678910111213141516function downloadFile(filename, data) &#123; let DownloadLink = document.createElement('a'); if (DownloadLink) &#123; document.body.appendChild(DownloadLink); DownloadLink.style = 'display: none'; DownloadLink.download = filename; DownloadLink.href = data; if (document.createEvent) &#123; let DownloadEvt = document.createEvent('MouseEvents'); DownloadEvt.initEvent('click', true, false); DownloadLink.dispatchEvent(DownloadEvt); &#125; else if (document.createEventObject) DownloadLink.fireEvent('onclick'); else if (typeof DownloadLink.onclick == 'function') DownloadLink.onclick(); document.body.removeChild(DownloadLink); &#125;&#125; 33. toFullScreen: 全屏123456function toFullScreen() &#123; let elem = document.body; elem.webkitRequestFullScreen ? elem.webkitRequestFullScreen() : elem.mozRequestFullScreen ? elem.mozRequestFullScreen() : elem.msRequestFullscreen ? elem.msRequestFullscreen() : elem.requestFullScreen ? elem.requestFullScreen() : alert(\"浏览器不支持全屏\");&#125; 34. exitFullscreen: 退出全屏123456function exitFullscreen() &#123; let elem = parent.document; elem.webkitCancelFullScreen ? elem.webkitCancelFullScreen() : elem.mozCancelFullScreen ? elem.mozCancelFullScreen() : elem.cancelFullScreen ? elem.cancelFullScreen() : elem.msExitFullscreen ? elem.msExitFullscreen() : elem.exitFullscreen ? elem.exitFullscreen() : alert(\"切换失败,可尝试Esc退出\");&#125; 35. requestAnimationFrame: window动画12345678window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function (callback) &#123; //为了使setTimteout的尽可能的接近每秒60帧的效果 window.setTimeout(callback, 1000 / 60); &#125;;window.cancelAnimationFrame = window.cancelAnimationFrame || Window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame || window.oCancelAnimationFrame || function (id) &#123; //为了使setTimteout的尽可能的接近每秒60帧的效果 window.clearTimeout(id); &#125; 36. _isNaN: 检查数据是否是非数字值原生的isNaN会把参数转换成数字(valueof)，而null、true、false以及长度小于等于1的数组(元素为非NaN数据)会被转换成数字，这不是我想要的。Symbol类型的数据不具有valueof接口，所以isNaN会抛出错误，这里放在后面，可避免错误 123function _isNaN(v)&#123; return !(typeof v === 'string' || typeof v === 'number') || isNaN(v)&#125; 37. max: 求取数组中非NaN数据中的最大值12345function max(arr)&#123; arr = arr.filter(item =&gt; !_isNaN(item)) return arr.length ? Math.max.apply(null, arr) : undefined&#125;//max([1, 2, '11', null, 'fdf', []]) ==&gt; 11 38. min: 求取数组中非NaN数据中的最小值12345function min(arr)&#123; arr = arr.filter(item =&gt; !_isNaN(item)) return arr.length ? Math.min.apply(null, arr) : undefined&#125;//min([1, 2, '11', null, 'fdf', []]) ==&gt; 1 39. random: 返回一个lower - upper之间的随机数lower、upper无论正负与大小，但必须是非NaN的数据 12345function random(lower, upper)&#123; lower = +lower || 0 upper = +upper || 0 return Math.random() * (upper - lower) + lower;&#125;//random(0, 0.5) ==&gt; 0.3567039135734613//random(2, 1) ===&gt; 1.6718418553475423//random(-2, -1) ==&gt; -1.4474325452361945 40. Object.keys: 返回一个由一个给定对象的自身可枚举属性组成的数组1Object.keys = Object.keys || function keys(object) &#123; if(object === null || object === undefined)&#123; throw new TypeError('Cannot convert undefined or null to object'); &#125; let result = [] if(isArrayLike(object) || isPlainObject(object))&#123; for (let key in object) &#123; object.hasOwnProperty(key) &amp;&amp; ( result.push(key) ) &#125; &#125; return result; 41. Object.values: 返回一个给定对象自身的所有可枚举属性值的数组123456789101112Object.values = Object.values || function values(object) &#123; if (object === null || object === undefined) &#123; throw new TypeError('Cannot convert undefined or null to object'); &#125; let result = [] if (isArrayLike(object) || isPlainObject(object)) &#123; for (let key in object) &#123; object.hasOwnProperty(key) &amp;&amp; (result.push(object[key])) &#125; &#125; return result&#125; 42. arr.fill: 使用 value 值来填充 array，从start位置开始, 到end位置结束（但不包含end位置），返回原数组123456789101112131415161718Array.prototype.fill = Array.prototype.fill || function fill(value, start, end) &#123; let ctx = this let length = ctx.length; start = parseInt(start) if (isNaN(start)) &#123; start = 0 &#125; else if (start &lt; 0) &#123; start = -start &gt; length ? 0 : (length + start); &#125; end = parseInt(end) if (isNaN(end) || end &gt; length) &#123; end = length &#125; else if (end &lt; 0) &#123; end += length; &#125; while (start &lt; end) &#123; ctx[start++] = value; &#125; return ctx;&#125; //Array(3).fill(2) ===&gt; [2, 2, 2] 43. arr.includes: 用来判断一个数组是否包含一个指定的值，如果是返回 true，否则false，可指定开始查询的位置12345678910Array.prototype.includes = Array.prototype.includes || function includes(value, start) &#123; let ctx = this let length = ctx.length; start = parseInt(start) if (isNaN(start)) &#123; start = 0 &#125; else if (start &lt; 0) &#123; start = -start &gt; length ? 0 : (length + start); &#125; let index = ctx.indexOf(value) return index &gt;= start;&#125; 44. arr.find: 返回数组中通过测试（函数fn内判断）的第一个元素的值1234567Array.prototype.find = Array.prototype.find || function find(fn, ctx) &#123; ctx = ctx || this let result; ctx.some((value, index, arr), thisValue) =&gt; &#123; return fn(value, index, arr) ? (result = value, true) : false &#125;) return result&#125; 45. arr.findIndex : 返回数组中通过测试（函数fn内判断）的第一个元素的下标1234567Array.prototype.findIndex = Array.prototype.findIndex || function findIndex(fn, ctx) &#123; ctx = ctx || this let result; ctx.some((value, index, arr), thisValue) =&gt; &#123; return fn(value, index, arr) ? (result = index, true) : false &#125;) return result&#125; 46. performance.timing: 利用performance.timing进行性能分析12345678910111213window.onload = function () &#123; setTimeout(function () &#123; let t = performance.timing console.log('DNS查询耗时 ：' + (t.domainLookupEnd - t.domainLookupStart).toFixed( 0)) console.log('TCP链接耗时 ：' + (t.connectEnd - t.connectStart).toFixed(0)) console.log( 'request请求耗时 ：' + (t.responseEnd - t.responseStart).toFixed(0)) console.log('解析dom树耗时 ：' + (t.domComplete - t.domInteractive).toFixed(0)) console.log('白屏时间 ：' + (t.responseStart - t.navigationStart) .toFixed(0)) console.log('domready时间 ：' + (t.domContentLoadedEventEnd - t.navigationStart).toFixed( 0)) console.log('onload时间 ：' + (t.loadEventEnd - t.navigationStart).toFixed(0)) if (t = performance.memory) &#123; console.log('js内存使用占比 ：' + (t.usedJSHeapSize / t.totalJSHeapSize * 100).toFixed(2) + '%') &#125; &#125;)&#125; 47. 禁止某些键盘事件1234567891011document.addEventListener('keydown', function (event) &#123; return !(112 == event.keyCode || //F1 123 == event.keyCode || //F12 event.ctrlKey &amp;&amp; 82 == event.keyCode || //ctrl + R event.ctrlKey &amp;&amp; 78 == event.keyCode || //ctrl + N event.shiftKey &amp;&amp; 121 == event.keyCode || //shift + F10 event.altKey &amp;&amp; 115 == event.keyCode || //alt + F4 \"A\" == event.srcElement.tagName &amp;&amp; event.shiftKey //shift + 点击a标签 ) || (event.returnValue = false) &#125;); 48. 禁止右键、选择、复制12345['contextmenu', 'selectstart', 'copy'].forEach(function (ev) &#123; document.addEventListener(ev, function (event) &#123; return event.returnValue = false &#125;)&#125;); 49. 防抖节流函数123456789101112131415161718192021// TODO 防抖函数export const debounce = (func, delay) =&gt; &#123; let timer = null; return (...args) =&gt; &#123; if (timer) clearTimeout(timer); timer = setTimeout(() =&gt; &#123; func.apply(this, args); &#125;, delay); &#125;&#125;;// 节流函数export const throttling = (fn, delay) =&gt; &#123; let lastTime = 0; return function () &#123; let nowTime = new Date().now(); if(nowTime - lastTime &gt; delay) &#123; fn.call(this); lastTime = nowTime; &#125; &#125; &#125; 50。格式化时间123456789101112131415161718192021222324export const formatDate = (date, fmt) =&gt; &#123; if (/(y+)/.test(fmt)) &#123; fmt = fmt.replace(RegExp.$1, (date.getFullYear() + '').substr(4 - RegExp.$1.length)); &#125; let o = &#123; 'M+': date.getMonth() + 1, 'd+': date.getDate(), 'h+': date.getHours(), 'm+': date.getMinutes(), 's+': date.getSeconds() &#125;; for (let k in o) &#123; if (new RegExp(`($&#123;k&#125;)`).test(fmt)) &#123; let str = o[k] + ''; fmt = fmt.replace(RegExp.$1, (RegExp.$1.length === 1) ? str : padLeftZero(str)); &#125; &#125; return fmt;&#125;;const padLeftZero = (str) =&gt; &#123; return ('00' + str).substr(str.length);&#125;; 51. 文件提取12345678910const bufferSplit = (buffer, delimiter) =&gt; &#123; let arr = &#123;&#125;; let n = 0; while ((n = buffer.indexOf(delimtter) != -1)) &#123; arr.push(buffer.slice(0, n)); buffer = buffer.slice(n + delimiter.length); &#125; arr.push(buffer); return arr;&#125; 52.生成随机颜色123456789function getRandomColor () &#123; let rgb = []; for (let i = 0; i &lt; 3; i++) &#123; let color = Math.floor(Math.random() * 256).toString(); color = color.length === 1 ? '0' + color : color; rgb.push(color); &#125; return '#' + rgb.join('');&#125; 53.驼峰命名12345678//已知有字符串foo='get-element-by-id',写一个function将其转化成驼峰表示法”getElementById”const toUpper = (str) =&gt; &#123; let arr = str.split('-'); // 字符串截取 for (let i = 1; i &lt; arr.length; i++) &#123; arr[i] = arr[i].charAt(0).toUpperCase() + arr[i].substr(1, arr[i].length - 1); &#125; return arr.join(''); // 字符串拼接&#125;; 54.排序去重123456789// ES6 sort Setvar arr = [32,4,67,82,21,11,11,11,11];arr = arr.sort((num1, num2) =&gt; &#123; return num1 - num2;&#125;);function unique(arr) &#123; return Array.from(new Set(arr))&#125; console.log(unique(arr)); 55.冒泡排序1234567891011121314151617181920212223242526272829303132333435363738// 排序let arr = [55, 11, 44, 66, 11, 2, 3, 4, 9]; for (let i = 0; i &lt; arr.length; i++) &#123; for (let j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; /** * arr[j] &gt; arr[j + 1] 升序 * arr[j] &lt; arr[j + 1] 降序 */ let temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; console.log(arr);// 去重//原数组 var arr = [8, 11, 20, 5, 20, 8, 0, 2, 4, 0, 8]; // 新数组 var t = [];//var t = [8,11]; t[0] = arr[0]; //arr中的每个元素 for (var i = 0; i &lt; arr.length; i++) &#123; //t中的每个元素 for (var k = 0; k &lt; t.length; k++) &#123; //当原数组中的值和新数组中的值相同的时候,就没有必要再继续比较了,跳出内循环 if (t[k] === arr[i]) &#123; break; &#125; //拿原数组中的某个元素比较到新数组中的最后一个元素还没有重复 if (k === t.length - 1) &#123; //将数据插入新数组 t.push(arr[i]); &#125; &#125; &#125; 56.数组反转12345678910111213// ES6 reversevar arr = [1,2,3,4,5,6,7,8];arr= arr.reverse();console.log(...arr);var arr = [1, 2, 3, 4, 5, 6, 7, 8]; for (var i = 0; i &lt; arr.length / 2; i++) &#123; //借助第三方变量交换两个变量的值 var temp = arr[i]; arr[i] = arr[arr.length - i]; arr[arr.length - i] = temp; &#125; console.log(arr); 57.css实现小三角123456#box &#123; width: 0; height: 0; border: 10px solid transparent; border-top-color: deeppink;&#125; 58.rem移动端适配12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1,user-scalable=no\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; *&#123; margin: 0; padding: 0; &#125; #box&#123; width: 8rem; height: 8rem; background: deeppink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"box\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; //获取屏幕宽度 var width = document.documentElement.clientWidth; //获取html var htmlNode = document.querySelector('html'); //设置html字体大小 htmlNode.style.fontSize = width/16 + 'px';&lt;/script&gt;&lt;/html&gt; 59.函数柯里化123456789101112131415161718192021222324252627function ParamsCurry (fn) &#123; let _arg = [].splice.call(arguments, 1); return function () &#123; let newArg = _arg.concat([].splice.call(arguments, 0)); return fn.apply(this, newArg); &#125;&#125;function Curry (fn) &#123; let length = length || fn.length; return function () &#123; if(arguments.length &lt; length) &#123; let combined = [fn].concat([].splice.call(arguments, 0)); return Curry(ParamsCurry.apply(this, combined), length - arguments.length); &#125; else &#123; return fn.apply(this, arguments); &#125; &#125;&#125;function add(a, b, c, d) &#123; return a + b + c + d;&#125;let demo = ParamsCurry(add);demo(1, 2, 3, 4);demo(1, 2, 3)(4);demo(1, 2)(3, 4);demo(1)(2)(3)(4); 60. 打印菱形1234567891011121314151617181920for (var i = 0; i &lt; 6; i++) &#123; for (var k = 0; k &lt; 6 - i - 1; k++) &#123; document.writeln(\" \"); &#125; for (var j = 0; j &lt;= (2 * i - 1) + 1; j++) &#123; document.writeln(\"*\"); &#125; document.writeln(\"&lt;br/&gt;\");&#125;//打印菱形的下半部分for (var i = 0; i &lt; 5; i++) &#123; for (var k = 0; k &lt; i + 1; k++) &#123; document.writeln(\" \"); &#125; for (var m = 0; m &lt; (9 - 3 * i) + i; m++) &#123; document.writeln(\"*\"); &#125; document.writeln(\"&lt;br/&gt;\");&#125; 61.冒泡排序12345678910111213const sort = (arr) =&gt; &#123; let temp = 0; for (lei i = 0; i &lt;= arr.length; i++) &#123; for (let j = 0; j &lt;= arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; // 升序 arr[j] &lt; arr[j+1] 降序 temp = arr[j] arr[j] = arr[j+1] arr[j+1] = temp &#125; &#125; &#125; return arr;&#125; 62. 随机取出字符123456789101112131415161718192021222324252627282930313233/** * @param min * @param max * @return &#123;number&#125; */function getRandom(min, max) &#123; return Math.floor(Math.random() * (max + 1 - min) + min)&#125;/** * * @param len * @return &#123;string&#125; */function getRandomStr(len) &#123; let template = \"\", index = \"\", result = \"\"; for (let i = 65; i &lt; 65 + 26; i++) &#123; template += String.fromCharCode(i); &#125; for (let i = 97; i &lt; 97 + 26; i++) &#123; template += String.fromCharCode(i); &#125; for (let i = 48; i &lt; 48 + 10; i++) &#123; template += String.fromCharCode(i); &#125; for (let i = 0; i&lt;len;i++) &#123; index = getRandom(0, template.length - 1); result += template[index]; &#125; return result;&#125; 63. 判断身份证的信息12345678910111213/** * @method getInfoPid * @param &#123;string&#125; pid * @return &#123;&#123;出生月份: number, 出生年份: number, 天数: number, 性别: (string)&#125;&#125; */function getInfoPid(pid) &#123; return &#123; \"出生年份\": +pid.substr(6, 4), \"出生月份\": +pid.substr(10, 2), \"天数\": +pid.substr(12, 2), \"性别\": pid[pid.length - 2] % 2 === 0 ? \"女\" : \"男\" &#125;&#125; 64. 获取年龄123456789101112131415const isLeap = (year) =&gt; &#123; return year % 4 === 0 &amp;&amp; year % 100 !== 0 || year %400 === 0&#125;const getAge = (year, month, day) =&gt; &#123; let now = new Date(); let age = new,getFullYear() - year; if (month === 2 &amp;&amp; day === 29 &amp;&amp; !isLeap(now.getFullYear())) &#123; day = 28; &#125; let birthThisDay = new Date(now.getFullYear(), month - 1, day); if (birthThisDay &gt; now) &#123; age --; &#125; return age;&#125; 65. 获取距离生日时间12345678910111213const getBirth = (montn, day) =&gt; &#123; let now = new Date(), year = now.getFullYear(), // 今年的生日 birthday = new Date(year, month - 1, day), dec = birthday - dec, days = dec / (24 * 60 * 60 * 1000); if (birthday &lt; now) &#123; // 今年生日已过。计算激励明年生日的时间 birthday.setFullYear(now.getFullYear + 1) &#125; return Math.ceil(days);&#125; 66. 获取当前月每一天的星期1234567891011const print = () =&gt; &#123; let now = new Date(), y = now.getFullYear(), m = now.getMonth() + 1, days = new Date(y, m, 0).getDate(), result = \"\"; for(let i = 1;i &lt; days; i++) &#123; result += `$&#123;y&#125;年$&#123;m&#125;月$&#123;i&#125;日,星期$&#123;new Date(y, m-1, i).getDay()&#125;` &#125; return result;&#125; 67. 快速生成文字1ul&gt;li*1&gt;lorem*1 68. 拖拽123456789101112131415161718192021222324252627282930/** * @method drop * @param &#123;HTMLElement&#125; element */const drop = (element) =&gt; &#123; // 不能用this，this指向window // console.log(this); let style = getComputedStyle(element), elementLeft = parseFloat(style.left), elementTop = parseFloat(style.top); element.onmousedown = (e) =&gt; &#123; let pageX = e.pageX, pageY = e.pageY; if (e.button !== 0) return; window.onmousemove = (e) =&gt; &#123; let disX = e.pageX - pageX, disY = e.pageY - pageY, newLeft = elementLeft + disX, newTop = elementTop + disY; if (newTop &lt; 0) &#123; newTop = 0; &#125; element.style.left = `$&#123;newLeft&#125;px`; element.style.top = `$&#123;newTop&#125;px`; &#125;; window.onmouseup = window.onmouseleave = (e) =&gt; &#123; if (e.button === 0) window.onmousemove = null; &#125; &#125;&#125;; 69. 评分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** 评分 * @method Score * @param &#123;HTMLElement&#125; element * @param &#123;string&#125; initSrc 初始图片 * @param &#123;string&#125; changeSrc 变化的图片 * @param &#123;HTMLElement&#125; word 获取文字区域 */const Score = (element, initSrc, changeSrc, word) =&gt; &#123; let wrap = ['满意', '一般', '还不错', '很满意', '非常满意']; let star = -1; element.onclick = (e) =&gt; &#123; if (e.target.tagName === 'IMG') &#123; // 记录评分 let index = Array.from(element.children).indexOf(e.target); &#125; &#125;; element.onmouseover = (e) =&gt; &#123; if (e.target.tagName === 'IMG') &#123; e.target.src = changeSrc; // 处理之前的 let prev = e.target.previousElementSibling; while (prev) &#123; prev.src = changeSrc; prev = prev.previousElementSibling; &#125; // 处理之后 let next = e.target.nextElementSibling; while (next) &#123; next.src = changeSrc; next = next.nextElementSibling; &#125; // 处理文字 // 得到父元素所有子元素 let index = Array.from(element.children).indexOf(e.target); word.innerHTML = wrap[index]; &#125; &#125;; element.onmouseleave = (e) =&gt; &#123; word.innerHTML = wrap[star] || \"\"; for (let i = 0; i &lt; element.children.length; i++) &#123; if (i &lt;= star) &#123; element.children[i].src = changeSrc; &#125; else &#123; element.children[i].src = initSrc; &#125; &#125; &#125;&#125;; 70. 吸顶效果12345678910111213141516171819const Ceiling = (element) =&gt; &#123; window.onscroll = (e) =&gt; &#123; let rect = element.getBoundingClientRect(); let scrollTop = 0; if (rect.top &lt; 0) &#123; element.style.position = 'fixed'; element.style.top = 0; element.style.left = rect.left + 'px'; element.style.width = rect.width + 'px'; element.style.height = rect.height + 'px'; element.style.boxSizing = 'border-box'; // 记录滚动条的位置 scrollTop = window.scrollY + rect.top; &#125; if (window.scrollY &lt; scrollTop) &#123; element.setAttribute(\"style\", \"\"); &#125; &#125;&#125;;","categories":[],"tags":[]}]}